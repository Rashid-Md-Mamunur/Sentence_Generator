function query=GenerateQuestion(truefalse)%% By Steven Dakin, UCL IoO, 2009 (s.dakin@ucl.ac.uk)%% A wrapper function for the generative grammar implemented in% GenerateGenStructureUS.m%% Call 'GenerateQuestion(1)' to get a true asserion,  'GenerateQuestion(0)' to get a false asserion,if ~exist('truefalse') % defaults to true    truefalse=1;endGenerateGenStructureUS;         % makes grammar - US variant - stores in 'object' structurequestions       = [{'some' 'no'}]; % two types of querywhichquestion   = 1;Nouns           = object(:,name); % All the objectsPosAssert       = object(:,some); % List of positive assertionsNegAssert       = object(:,none); % List of negative assertionsrunningot       = 1;truerunningot   = 1;for i=1:NoObjects    oblist1 = object(ObjectNo,name);    noprops = length([PosAssert{i,1}])*length([Nouns{i,1}]); % no positive assertions    PosProps(runningot:runningot+noprops-1) = i; % record ObjectNumber for each asserion    runningot = runningot+noprops; % add them up    truerunningot = truerunningot+noprops+(length([NegAssert{i,1}])*length([Nouns{i,1}])); % all assertions (T+F)endNumberProps=runningot;% generate queryposs=0;while (poss==0) % run this until we find a valid query - allows for empty fields in object    ObjectNo    = PosProps(1+floor(rand*NumberProps)); % Select random object    Qtype1      = 1+floor(rand*2); % random question type    if truefalse % select question type        Qtype2 = Qtype1;        % 1->1, 2->2    else        Qtype2 = (1-Qtype1)+2;  % 1->2, 2->1    end    proplist1   = object(ObjectNo,Qtype2+1);    proplist2   = proplist1{1};    poss        = length(proplist2); % possible (true or false depending on Qtype) states    oblist1     = object(ObjectNo,name); % possible objects    oblist2     = oblist1{1};    poss2       = length(oblist2);endinst    = 1 + floor(rand*poss);inst2   = 1 + floor(rand*poss2);qlist(whichquestion,:) = [ObjectNo Qtype2 inst];property = proplist2{inst};if (iscellstr(oblist1))    this_object = oblist2;else    this_object = oblist2{inst2};end% generate the query-stringquery           = sprintf('%s %s %s',char(questions(Qtype1)),char(this_object),char(property));% double negative correctionStartsNo        = findstr('no ',query(1:2)); % starts with noNegStatement    = findstr('n''t',query); % is a negative staementif (NegStatement&StartsNo) % double negative    query2 = sprintf('all%s %s',query(3:NegStatement(1)-1),query(NegStatement(1)+4:length(query)));    query  = query2;    %    fprintf(1,'"nt" Double negative corrected %s',query);endNeverStatement=findstr('never',query); % another variantif (NeverStatement&StartsNo)    query2 = sprintf('all%ssometimes %s',query(3:NeverStatement(1)-1),query(NeverStatement(1)+6:length(query)));    query  = query2;    %   fprintf(1,'"never" Double negative corrected %s',query);end